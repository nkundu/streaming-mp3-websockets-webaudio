// Generated by CoffeeScript 1.11.1
(function() {
  var BinaryServer, Mp3Frame, bs, bss, clientConnected, curClient, first, fs, lastFrameIdx, mergeAndSendFrames, mp3FragmentIdx, mp3Frames, mpeg_bitrates, mpeg_frame_samples, mpeg_slot_size, mpeg_srates, numMp3Fragments, numSegments, parseMp3File, startServer, stream, streamDrained, syncWord;

  fs = require('fs');

  bs = require('binaryjs');

  BinaryServer = bs.BinaryServer;

  bss = null;

  curClient = null;

  stream = null;

  mp3FragmentIdx = 0;

  numMp3Fragments = 20;

  mp3Frames = [];

  lastFrameIdx = 0;

  first = true;

  syncWord = 0;

  numSegments = 0;

  mpeg_bitrates = [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0], [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0], [0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0], [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0], [0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 0], [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 0], [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 0]]];

  mpeg_srates = [[11025, 12000, 8000, 0], [0, 0, 0, 0], [22050, 24000, 16000, 0], [44100, 48000, 32000, 0]];

  mpeg_frame_samples = [[0, 576, 1152, 384], [0, 0, 0, 0], [0, 576, 1152, 384], [0, 1152, 1152, 384]];

  mpeg_slot_size = [0, 1, 1, 4];

  Mp3Frame = (function() {
    function Mp3Frame(length) {
      this.mp3FrameBuf = new Buffer(length);
      this.mp3FrameLength = length;
    }

    return Mp3Frame;

  })();

  startServer = function() {
    bss = new BinaryServer({
      port: 9696
    });
    return bss.on('connection', clientConnected);
  };

  mergeAndSendFrames = function() {
    var i, j, k, limit, mergedBuffer, mergedBufferIdx, ref, ref1, ref2, ref3, sizeBuffer;
    sizeBuffer = 0;
    limit = mp3FragmentIdx + numMp3Fragments;
    if (limit > mp3Frames.length) {
      limit = mp3Frames.length;
    }
    for (i = j = ref = mp3FragmentIdx, ref1 = limit; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      sizeBuffer += mp3Frames[i].mp3FrameLength;
    }
    mergedBuffer = new Buffer(sizeBuffer);
    mergedBufferIdx = 0;
    for (i = k = ref2 = mp3FragmentIdx, ref3 = limit; ref2 <= ref3 ? k < ref3 : k > ref3; i = ref2 <= ref3 ? ++k : --k) {
      mp3Frames[i].mp3FrameBuf.copy(mergedBuffer, mergedBufferIdx, 0);
      mergedBufferIdx += mp3Frames[i].mp3FrameLength;
    }
    mp3FragmentIdx = limit;
    if (sizeBuffer > 0) {
      stream.write(mergedBuffer);
    }
    return sizeBuffer;
  };

  clientConnected = function(client) {
    if (curClient !== null) {
      curClient.close();
    }
    curClient = client;
    console.log("Client connected, will send first mp3 frame");
    stream = client.createStream();
    stream.on('drain', streamDrained);
    return mergeAndSendFrames();
  };

  streamDrained = function() {
    if (mergeAndSendFrames() === 0) {
      console.log("Sent", mp3FragmentIdx, "frames");
      mp3FragmentIdx = 0;
      stream.removeListener('drain', streamDrained);
      return stream.end();
    }
  };

  parseMp3File = function(err, data) {
    var bitrate, brx, frame, frameSum, fsize, headerIdx, header_size, lyr, numFrames, pad, samples, samprate, slot_size, srx, time_length, ver;
    numFrames = 0;
    header_size = data[9] & 0x7f | ((data[8] & 0x7f) << 7) | ((data[7] & 0x7f) << 14) | ((data[6] & 0x7f) << 21);
    headerIdx = header_size + 10;
    console.log("Header size", header_size);
    frameSum = 0;
    while (headerIdx < data.length) {
      if (headerIdx + 1 < data.length && data[headerIdx] === 0xFF) {
        syncWord = (data[headerIdx] << 8) | data[headerIdx + 1];
        if (syncWord === 0xFFFB || syncWord === 0xFFFA) {
          ver = (data[headerIdx + 1] & 0x18) >> 3;
          lyr = (data[headerIdx + 1] & 0x06) >> 1;
          pad = (data[headerIdx + 2] & 0x02) >> 1;
          brx = (data[headerIdx + 2] & 0xf0) >> 4;
          srx = (data[headerIdx + 2] & 0x0c) >> 2;
          bitrate = mpeg_bitrates[ver][lyr][brx] * 1000;
          samprate = mpeg_srates[ver][srx];
          samples = mpeg_frame_samples[ver][lyr];
          slot_size = pad === 1 ? mpeg_slot_size[lyr] : 0;
          console.log("Version", ver);
          console.log("Layer", lyr);
          console.log("Bitrate", bitrate);
          console.log("Frequency", samprate);
          console.log("Samples", samples);
          console.log("Padding", pad);
          console.log("Slot size", slot_size);
          console.log("Header idx", headerIdx);
          time_length = samples / samprate;
          fsize = Math.floor(((bitrate / 8) * time_length) + slot_size);
          frame = new Mp3Frame(fsize);
          data.copy(frame.mp3FrameBuf, 0, headerIdx, headerIdx + fsize);
          mp3Frames.push(frame);
          numFrames++;
          headerIdx += fsize;
        }
      } else {
        break;
      }
    }
    console.log("File length", data.length);
    console.log("HeaderIdx", headerIdx);
    console.log("MP3 frames " + numFrames);
    console.log("Will start streaming server");
    return startServer();
  };

  fs.readFile(process.argv[2], parseMp3File);

}).call(this);
